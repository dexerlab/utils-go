// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package pquery

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/dexerlab/utils-go/dal/pmodel"
)

func newTLiquidityModify(db *gorm.DB, opts ...gen.DOOption) tLiquidityModify {
	_tLiquidityModify := tLiquidityModify{}

	_tLiquidityModify.tLiquidityModifyDo.UseDB(db, opts...)
	_tLiquidityModify.tLiquidityModifyDo.UseModel(&pmodel.TLiquidityModify{})

	tableName := _tLiquidityModify.tLiquidityModifyDo.TableName()
	_tLiquidityModify.ALL = field.NewAsterisk(tableName)
	_tLiquidityModify.Ts = field.NewTime(tableName, "ts")
	_tLiquidityModify.PoolID = field.NewInt64(tableName, "pool_id")
	_tLiquidityModify.Amount0 = field.NewFloat64(tableName, "amount0")
	_tLiquidityModify.Amount1 = field.NewFloat64(tableName, "amount1")
	_tLiquidityModify.Amountu = field.NewFloat64(tableName, "amountu")

	_tLiquidityModify.fillFieldMap()

	return _tLiquidityModify
}

type tLiquidityModify struct {
	tLiquidityModifyDo tLiquidityModifyDo

	ALL     field.Asterisk
	Ts      field.Time
	PoolID  field.Int64
	Amount0 field.Float64
	Amount1 field.Float64
	Amountu field.Float64

	fieldMap map[string]field.Expr
}

func (t tLiquidityModify) Table(newTableName string) *tLiquidityModify {
	t.tLiquidityModifyDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tLiquidityModify) As(alias string) *tLiquidityModify {
	t.tLiquidityModifyDo.DO = *(t.tLiquidityModifyDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tLiquidityModify) updateTableName(table string) *tLiquidityModify {
	t.ALL = field.NewAsterisk(table)
	t.Ts = field.NewTime(table, "ts")
	t.PoolID = field.NewInt64(table, "pool_id")
	t.Amount0 = field.NewFloat64(table, "amount0")
	t.Amount1 = field.NewFloat64(table, "amount1")
	t.Amountu = field.NewFloat64(table, "amountu")

	t.fillFieldMap()

	return t
}

func (t *tLiquidityModify) WithContext(ctx context.Context) ITLiquidityModifyDo {
	return t.tLiquidityModifyDo.WithContext(ctx)
}

func (t tLiquidityModify) TableName() string { return t.tLiquidityModifyDo.TableName() }

func (t tLiquidityModify) Alias() string { return t.tLiquidityModifyDo.Alias() }

func (t tLiquidityModify) Columns(cols ...field.Expr) gen.Columns {
	return t.tLiquidityModifyDo.Columns(cols...)
}

func (t *tLiquidityModify) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tLiquidityModify) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 5)
	t.fieldMap["ts"] = t.Ts
	t.fieldMap["pool_id"] = t.PoolID
	t.fieldMap["amount0"] = t.Amount0
	t.fieldMap["amount1"] = t.Amount1
	t.fieldMap["amountu"] = t.Amountu
}

func (t tLiquidityModify) clone(db *gorm.DB) tLiquidityModify {
	t.tLiquidityModifyDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t tLiquidityModify) replaceDB(db *gorm.DB) tLiquidityModify {
	t.tLiquidityModifyDo.ReplaceDB(db)
	return t
}

type tLiquidityModifyDo struct{ gen.DO }

type ITLiquidityModifyDo interface {
	gen.SubQuery
	Debug() ITLiquidityModifyDo
	WithContext(ctx context.Context) ITLiquidityModifyDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITLiquidityModifyDo
	WriteDB() ITLiquidityModifyDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITLiquidityModifyDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITLiquidityModifyDo
	Not(conds ...gen.Condition) ITLiquidityModifyDo
	Or(conds ...gen.Condition) ITLiquidityModifyDo
	Select(conds ...field.Expr) ITLiquidityModifyDo
	Where(conds ...gen.Condition) ITLiquidityModifyDo
	Order(conds ...field.Expr) ITLiquidityModifyDo
	Distinct(cols ...field.Expr) ITLiquidityModifyDo
	Omit(cols ...field.Expr) ITLiquidityModifyDo
	Join(table schema.Tabler, on ...field.Expr) ITLiquidityModifyDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITLiquidityModifyDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITLiquidityModifyDo
	Group(cols ...field.Expr) ITLiquidityModifyDo
	Having(conds ...gen.Condition) ITLiquidityModifyDo
	Limit(limit int) ITLiquidityModifyDo
	Offset(offset int) ITLiquidityModifyDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITLiquidityModifyDo
	Unscoped() ITLiquidityModifyDo
	Create(values ...*pmodel.TLiquidityModify) error
	CreateInBatches(values []*pmodel.TLiquidityModify, batchSize int) error
	Save(values ...*pmodel.TLiquidityModify) error
	First() (*pmodel.TLiquidityModify, error)
	Take() (*pmodel.TLiquidityModify, error)
	Last() (*pmodel.TLiquidityModify, error)
	Find() ([]*pmodel.TLiquidityModify, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*pmodel.TLiquidityModify, err error)
	FindInBatches(result *[]*pmodel.TLiquidityModify, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*pmodel.TLiquidityModify) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITLiquidityModifyDo
	Assign(attrs ...field.AssignExpr) ITLiquidityModifyDo
	Joins(fields ...field.RelationField) ITLiquidityModifyDo
	Preload(fields ...field.RelationField) ITLiquidityModifyDo
	FirstOrInit() (*pmodel.TLiquidityModify, error)
	FirstOrCreate() (*pmodel.TLiquidityModify, error)
	FindByPage(offset int, limit int) (result []*pmodel.TLiquidityModify, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITLiquidityModifyDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t tLiquidityModifyDo) Debug() ITLiquidityModifyDo {
	return t.withDO(t.DO.Debug())
}

func (t tLiquidityModifyDo) WithContext(ctx context.Context) ITLiquidityModifyDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tLiquidityModifyDo) ReadDB() ITLiquidityModifyDo {
	return t.Clauses(dbresolver.Read)
}

func (t tLiquidityModifyDo) WriteDB() ITLiquidityModifyDo {
	return t.Clauses(dbresolver.Write)
}

func (t tLiquidityModifyDo) Session(config *gorm.Session) ITLiquidityModifyDo {
	return t.withDO(t.DO.Session(config))
}

func (t tLiquidityModifyDo) Clauses(conds ...clause.Expression) ITLiquidityModifyDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tLiquidityModifyDo) Returning(value interface{}, columns ...string) ITLiquidityModifyDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tLiquidityModifyDo) Not(conds ...gen.Condition) ITLiquidityModifyDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tLiquidityModifyDo) Or(conds ...gen.Condition) ITLiquidityModifyDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tLiquidityModifyDo) Select(conds ...field.Expr) ITLiquidityModifyDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tLiquidityModifyDo) Where(conds ...gen.Condition) ITLiquidityModifyDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tLiquidityModifyDo) Order(conds ...field.Expr) ITLiquidityModifyDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tLiquidityModifyDo) Distinct(cols ...field.Expr) ITLiquidityModifyDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tLiquidityModifyDo) Omit(cols ...field.Expr) ITLiquidityModifyDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tLiquidityModifyDo) Join(table schema.Tabler, on ...field.Expr) ITLiquidityModifyDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tLiquidityModifyDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITLiquidityModifyDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tLiquidityModifyDo) RightJoin(table schema.Tabler, on ...field.Expr) ITLiquidityModifyDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tLiquidityModifyDo) Group(cols ...field.Expr) ITLiquidityModifyDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tLiquidityModifyDo) Having(conds ...gen.Condition) ITLiquidityModifyDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tLiquidityModifyDo) Limit(limit int) ITLiquidityModifyDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tLiquidityModifyDo) Offset(offset int) ITLiquidityModifyDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tLiquidityModifyDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITLiquidityModifyDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tLiquidityModifyDo) Unscoped() ITLiquidityModifyDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tLiquidityModifyDo) Create(values ...*pmodel.TLiquidityModify) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tLiquidityModifyDo) CreateInBatches(values []*pmodel.TLiquidityModify, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tLiquidityModifyDo) Save(values ...*pmodel.TLiquidityModify) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tLiquidityModifyDo) First() (*pmodel.TLiquidityModify, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*pmodel.TLiquidityModify), nil
	}
}

func (t tLiquidityModifyDo) Take() (*pmodel.TLiquidityModify, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*pmodel.TLiquidityModify), nil
	}
}

func (t tLiquidityModifyDo) Last() (*pmodel.TLiquidityModify, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*pmodel.TLiquidityModify), nil
	}
}

func (t tLiquidityModifyDo) Find() ([]*pmodel.TLiquidityModify, error) {
	result, err := t.DO.Find()
	return result.([]*pmodel.TLiquidityModify), err
}

func (t tLiquidityModifyDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*pmodel.TLiquidityModify, err error) {
	buf := make([]*pmodel.TLiquidityModify, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tLiquidityModifyDo) FindInBatches(result *[]*pmodel.TLiquidityModify, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tLiquidityModifyDo) Attrs(attrs ...field.AssignExpr) ITLiquidityModifyDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tLiquidityModifyDo) Assign(attrs ...field.AssignExpr) ITLiquidityModifyDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tLiquidityModifyDo) Joins(fields ...field.RelationField) ITLiquidityModifyDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t tLiquidityModifyDo) Preload(fields ...field.RelationField) ITLiquidityModifyDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t tLiquidityModifyDo) FirstOrInit() (*pmodel.TLiquidityModify, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*pmodel.TLiquidityModify), nil
	}
}

func (t tLiquidityModifyDo) FirstOrCreate() (*pmodel.TLiquidityModify, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*pmodel.TLiquidityModify), nil
	}
}

func (t tLiquidityModifyDo) FindByPage(offset int, limit int) (result []*pmodel.TLiquidityModify, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tLiquidityModifyDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t tLiquidityModifyDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t tLiquidityModifyDo) Delete(models ...*pmodel.TLiquidityModify) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *tLiquidityModifyDo) withDO(do gen.Dao) *tLiquidityModifyDo {
	t.DO = *do.(*gen.DO)
	return t
}
